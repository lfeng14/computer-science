- 如何动态链接、动态加载 ?
- 不用execv e而仅用mmap来实现加载程序
- <img width="2036" height="1012" alt="image" src="https://github.com/user-attachments/assets/649c1a94-21b5-481e-8b2e-92f82ae912d3" />
<img width="2074" height="1052" alt="image" src="https://github.com/user-attachments/assets/22d46469-cd65-4b84-a90d-a919afd8636e" />
- 通过ld mmap来加载到内存、initprocess(设置entry、rsp栈)；所以linux kernel的加载器运行也是同理
- 亲手调试下，不管使用mmap映射到内存还是通过指令读取硬盘到内存，方法都是类似的
<img width="2048" height="826" alt="image" src="https://github.com/user-attachments/assets/6c1ccf5d-2c92-44f3-be02-4f23eb4644c3" />
- kernel entry 0x1000000处指令，所以gdb调试时，可以直接用b *0x1000000打断点
- gdb vmlinux -ex "target remote localhost:1234" 远程调试
- 为什么需要动态库，比如glibc有个紧急补丁，若采用静态链接，那么所有代码估计都得构建
- 调用外部库函数：call dsym(putchar@plt)
- 自己构建一套工具链：readdl objdump gcc; main.s -> libhello.s -> libc.s
- <img width="1942" height="968" alt="image" src="https://github.com/user-attachments/assets/c7bd00fc-3752-413b-bc04-89d1c527ade0" />
- 通过gcc将二进制部分给挖出来
<img width="2078" height="970" alt="image" src="https://github.com/user-attachments/assets/7fbfef80-e839-4538-8264-190d60db43d0" />
- 代码：https://jyywiki.cn/OS/2022/slides/17.slides.html#/2/5
