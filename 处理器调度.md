- 优先级，man nice，top；越nice越让别人得到cpu
- <img width="1066" height="736" alt="image" src="https://github.com/user-attachments/assets/0361973f-773a-42b1-bb60-89f1d40064eb" />
<img width="2076" height="1004" alt="image" src="https://github.com/user-attachments/assets/8139de30-ecec-419b-8205-30edb5b8c763" />
- 策略：动态优先级，根据历史运行情况；但好与坏是会变化的；
- 一旦进程开始协作这时调用迎来更多挑战：例如持有锁的人，cpu被切出去了，另外一个进程想获取锁，这时是不是
- 1997年火星车上的技术都是你们可以从课堂上学到的，是不是感想敢做; 20MIPS：每秒2000条指令；vxworks实时操作系统
  ```
    void xiao_zhang() { // 高优先级
    sleep(1); // 休息一下先
    mutex_lock(&wc);
    ...
    }
    
    void xi_zhu_ren() { // 中优先级
      while (1) ;
    }
    
    void jyy() { // 最低优先级
      mutex_lock(&wc); // 刚开始先执行
      ...
    }
  ```
  典型的优先级反转（Priority Inversion） 场景，会导致死锁问题。火星车（如1997年的火星探路者号）确实遇到过类似问题。
  问题分析：
  执行时序：
  - jyy（低优先级） 先运行，成功获取互斥锁 wc
  - xiao_zhang（高优先级） 就绪，抢占jyy的CPU
  - xiao_zhang尝试获取 wc，但锁已被持有，于是阻塞等待
  - xi_zhu_ren（中优先级） 就绪，抢占CPU（因为优先级高于jyy）
  - xi_zhu_ren进入无限循环，永不释放CPU
  结果：
  - jyy（持有锁）无法运行，无法释放锁
  - xiao_zhang（等待锁）永远阻塞
  - xi_zhu_ren永远占用CPU
  - 系统死锁
  处理措施获得锁后优先级反转
<img width="1070" height="712" alt="image" src="https://github.com/user-attachments/assets/8d2087e9-92e6-4acb-9337-6e5f2457019d" />
<img width="1066" height="776" alt="image" src="https://github.com/user-attachments/assets/eb395283-4158-4ccf-82bb-9b8da462e610" />
<img width="866" height="592" alt="image" src="https://github.com/user-attachments/assets/c1d1e665-1b29-4992-ba03-ec14644d6b7c" />
- 每个处理器的L1 cache都是独立的；L2都是处理器之间共享的；
- <img width="1870" height="1322" alt="image" src="https://github.com/user-attachments/assets/ea93dbdb-b255-445f-a16a-cf7727ebc1e7" />

##### 课件：https://jyywiki.cn/OS/2022/slides/20.slides.html#/3/1
