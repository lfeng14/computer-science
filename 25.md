- 大模型知识、信息平权
- 操作系统是让程序运行起来的一个软件，管理应用，提供服务
- info locals
- c语言也有解释器，a very small c interpreter for scripting
- ret时，栈没有下一个栈帧；没有main也能执行：
  这个看起来像C语言的程序之所以能够执行，主要有以下几个原因：
  - 1. **使用了特殊的入口点 `_start`**
  - 标准的C程序入口点是 `main()` 函数
  - 但这个程序使用 `_start()` 作为入口点，这是链接器默认的入口点
  - 在Linux系统中，`_start` 是ELF可执行文件的实际入口
  
  - 2. **直接使用系统调用退出**
  - 程序通过内联汇编直接调用Linux系统调用（syscall）
  - `$60` 是Linux x86_64下的exit系统调用号
  - `$99` 是程序的退出状态码
  
  - 3. **绕过了C运行时环境**
  - 这个程序没有调用C标准库函数
  - 没有初始化全局变量、堆栈等运行时环境
  - 直接进入程序逻辑并立即退出
  
  - 4. **编译器处理**
  虽然代码看起来简单，但编译时需要特殊处理：
  ```bash
  # 编译命令可能类似这样：
  gcc -nostdlib -nostartfiles hello.c -o hello
  ```
  - `-nostdlib`: 不链接标准库
  - `-nostartfiles`: 不使用标准的启动文件
  
  - 5. **注意代码错误**
  实际上，提供的代码有一个语法错误：
  ```c
  "mov $99, %ei, %edi\n"  // 应该是 "mov $99, %edi"
  ```
  修复后的代码应该是：
  ```c
  void _start() {
      asm("mov $60, %eax\n"  // syscall: exit
          "mov $99, %edi\n"  // exit status: 99
          "syscall");
  }
  ```
  这个程序能执行，主要是因为它是直接与操作系统交互的最小化程序，绕过了C语言通常的初始化过程。不过在实际应用中，这种写法很少见，主要用于系统编程或学习操作系统原理。
- 动动手学的更好
  ```
  void son() {
     int a = 1;
     a = 2;
     a = 3;
  }
  int main() {
     son();
     return 0;
  }
  ```
  
  ```
  0000000000000718 <son>:
   718:	d10043ff 	sub	sp, sp, #0x10
   71c:	52800020 	mov	w0, #0x1                   	// #1
   720:	b9000fe0 	str	w0, [sp, #12]
   724:	52800040 	mov	w0, #0x2                   	// #2
   728:	b9000fe0 	str	w0, [sp, #12]
   72c:	52800060 	mov	w0, #0x3                   	// #3
   730:	b9000fe0 	str	w0, [sp, #12]
   734:	d503201f 	nop
   738:	910043ff 	add	sp, sp, #0x10
   73c:	d65f03c0 	ret
  
  0000000000000740 <main>:
   740:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
   744:	910003fd 	mov	x29, sp
   748:	97fffff4 	bl	718 <son>
   74c:	52800000 	mov	w0, #0x0                   	// #0
   750:	a8c17bfd 	ldp	x29, x30, [sp], #16
   754:	d65f03c0 	ret
  
  Disassembly of section .fini:
  
  0000000000000758 <_fini>:
   758:	d503201f 	nop
   75c:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
   760:	910003fd 	mov	x29, sp
   764:	a8c17bfd 	ldp	x29, x30, [sp], #16
   768:	d65f03c0 	ret
  ```
- x64系统调用编号放到eax寄存器;系统调用参数传递:man syscall; main函数结束后，是libc来通过系统调用来退出；
<img width="1076" height="664" alt="image" src="https://github.com/user-attachments/assets/c63fcfb7-c98a-40b1-868e-16d1ccb6a087" />
- 使用nm来查看vscdoe使用哪些函数
- strace -f gcc demo.c观察出现了哪些系统调用；gcc本身不能调用另外一个二进程，所以必须通过系统调用；

  <img width="994" height="700" alt="image" src="https://github.com/user-attachments/assets/4030ed45-02b6-4ef7-89d2-11e15505bad2" />
- 机械硬盘盘片增加速度才增加；但是flash memory只要集成电路在单位体积内能制作出速度就能上去；容量越大越快；速度几乎跟主存差不多，1991年出现；即固态硬盘和usb；就是今天最主要的存储设别；
 <img width="1088" height="782" alt="image" src="https://github.com/user-attachments/assets/c31cb48a-65fb-4c1a-8896-84413cd9e453" />
- flash memory 有wear out问题，通过增加flash translation layer 
<img width="1030" height="652" alt="image" src="https://github.com/user-attachments/assets/40092b27-5826-4778-9243-461035034038" />
<img width="1056" height="784" alt="image" src="https://github.com/user-attachments/assets/d6045dcb-54c2-4ba7-880c-7df99067a542" />
- dram（内存） sram（L1L2L3） 都是易失存储，volatile；
- 输入输出设别，比如打印机，api需要发数据画线获取打印机状态；有计算机，有自动化控制，有流水线，敢于尝试。
- cpu如何协调不同速度的设备，比如dram、io设备。通过总线来统一访问，io慢通过中断机制通知cpu；cpi是一种总线通信协议，软硬件共同实现；随着设备越来越多是个挑战；
- qemu可以添加设备，比如声卡，可以通过下面示例来打印印证；
  <img width="1080" height="698" alt="image" src="https://github.com/user-attachments/assets/b52f2016-ac94-43f9-82c8-0895846e983f" />
- 中断处理器，cpu与外部设备的中间人；引脚控制中断；可编程的中断控制器；
  <img width="1096" height="760" alt="image" src="https://github.com/user-attachments/assets/3d9750b9-0baf-4d83-b2ba-e5a0a7e0021e" />
- 磁盘没有准备好cpu可以干别的事情；磁盘准备通过发一个中断来通知cpu；但是还有一个问题就是需要写大量数据到磁盘场景；通过增加一个cpu来实现内存到总线的搬移，这就是DMA；
- intel amd的驱动工程师对这块表了解；
  <img width="994" height="748" alt="image" src="https://github.com/user-attachments/assets/17869ef6-9cd2-4967-b69f-d73ea4c15dc1" />
  <img width="1158" height="806" alt="image" src="https://github.com/user-attachments/assets/97d89247-2793-4c56-b7ad-1adb3c9c1049" />


