- 大模型知识、信息平权
- 操作系统是让程序运行起来的一个软件，管理应用，提供服务
- info locals
- c语言也有解释器，a very small c interpreter for scripting
- ret时，栈没有下一个栈帧；没有main也能执行：
  这个看起来像C语言的程序之所以能够执行，主要有以下几个原因：
  - 1. **使用了特殊的入口点 `_start`**
  - 标准的C程序入口点是 `main()` 函数
  - 但这个程序使用 `_start()` 作为入口点，这是链接器默认的入口点
  - 在Linux系统中，`_start` 是ELF可执行文件的实际入口
  
  - 2. **直接使用系统调用退出**
  - 程序通过内联汇编直接调用Linux系统调用（syscall）
  - `$60` 是Linux x86_64下的exit系统调用号
  - `$99` 是程序的退出状态码
  
  - 3. **绕过了C运行时环境**
  - 这个程序没有调用C标准库函数
  - 没有初始化全局变量、堆栈等运行时环境
  - 直接进入程序逻辑并立即退出
  
  - 4. **编译器处理**
  虽然代码看起来简单，但编译时需要特殊处理：
  ```bash
  # 编译命令可能类似这样：
  gcc -nostdlib -nostartfiles hello.c -o hello
  ```
  - `-nostdlib`: 不链接标准库
  - `-nostartfiles`: 不使用标准的启动文件
  
  - 5. **注意代码错误**
  实际上，提供的代码有一个语法错误：
  ```c
  "mov $99, %ei, %edi\n"  // 应该是 "mov $99, %edi"
  ```
  修复后的代码应该是：
  ```c
  void _start() {
      asm("mov $60, %eax\n"  // syscall: exit
          "mov $99, %edi\n"  // exit status: 99
          "syscall");
  }
  ```
  这个程序能执行，主要是因为它是直接与操作系统交互的最小化程序，绕过了C语言通常的初始化过程。不过在实际应用中，这种写法很少见，主要用于系统编程或学习操作系统原理。
- 
```
void son() {
   int a = 1;
   a = 2;
   a = 3;
}
int main() {
   son();
   return 0;
}
```

```
0000000000000718 <son>:
 718:	d10043ff 	sub	sp, sp, #0x10
 71c:	52800020 	mov	w0, #0x1                   	// #1
 720:	b9000fe0 	str	w0, [sp, #12]
 724:	52800040 	mov	w0, #0x2                   	// #2
 728:	b9000fe0 	str	w0, [sp, #12]
 72c:	52800060 	mov	w0, #0x3                   	// #3
 730:	b9000fe0 	str	w0, [sp, #12]
 734:	d503201f 	nop
 738:	910043ff 	add	sp, sp, #0x10
 73c:	d65f03c0 	ret

0000000000000740 <main>:
 740:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
 744:	910003fd 	mov	x29, sp
 748:	97fffff4 	bl	718 <son>
 74c:	52800000 	mov	w0, #0x0                   	// #0
 750:	a8c17bfd 	ldp	x29, x30, [sp], #16
 754:	d65f03c0 	ret

Disassembly of section .fini:

0000000000000758 <_fini>:
 758:	d503201f 	nop
 75c:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
 760:	910003fd 	mov	x29, sp
 764:	a8c17bfd 	ldp	x29, x30, [sp], #16
 768:	d65f03c0 	ret
```
